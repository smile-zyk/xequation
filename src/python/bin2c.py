import argparse
import os
import re
import sys
import datetime

PY3 = sys.version_info[0] == 3


def bin2header(filename, varname='data', linesize=80, indent=4, namespace=None):
    """ Read binary data from file and return as a C++ header file
    
    :param filename: a filename of a file to read.
    :param varname: a C array variable name.
    :param linesize: a size of a line (min value is 40).
    :param indent: an indent (number of spaces) that prepend each line.
    :param namespace: optional C++ namespace to wrap the array.
    """
    if not os.path.isfile(filename):
        print('File "%s" is not found!' % filename)
        return ''
    if not re.match('[a-zA-Z_][a-zA-Z0-9_]*', varname):
        print('Invalid variable name "%s"' % varname)
        return ''
    
    # Read binary data
    with open(filename, 'rb') as in_file:
        data = in_file.read()
    
    # Limit the line length
    if linesize < 40:
        linesize = 40
    
    # Generate header guard
    header_guard = varname.upper().replace('.', '_').replace('-', '_') + '_H'
    
    # 实际变量名（添加 _data 后缀）
    array_varname = varname + '_data'
    
    # Prepare file info
    file_size = len(data)
    timestamp = datetime.datetime.now().strftime("%Y-%m-%d %H:%M:%S")
    source_filename = os.path.basename(filename)
    
    # Start building the header
    out = f'#ifndef {header_guard}\n'
    out += f'#define {header_guard}\n\n'
    
    # Add file information comment
    out += f'/*\n'
    out += f' * File: {varname}_embed.h\n'
    out += f' * Generated by bin2c on {timestamp}\n'
    out += f' * Source file: {source_filename}\n'
    out += f' * File size: {file_size} bytes\n'
    out += f' */\n\n'
    
    # Start namespace if specified
    if namespace:
        out += f'namespace {namespace} {{\n\n'
    
    # Generate array declaration with constexpr
    out += f'constexpr unsigned char {array_varname}[{file_size}] = {{\n'
    
    # Generate array data
    byte_len = 6  # '0x00, '
    line = ''
    byte_count = 0
    
    for byte in data:
        line += '0x%02x, ' % (byte if PY3 else ord(byte))
        byte_count += 1
        
        if len(line) + indent + byte_len >= linesize:
            out += ' ' * indent + line + '\n'
            line = ''
    
    # Add the last line
    if line:
        out += ' ' * indent + line + '\n'
    
    # Strip the last comma
    out = out.rstrip(', \n') + '\n'
    out += '};\n\n'
    
    # Add size constant with constexpr
    out += f'constexpr unsigned int {varname}_size = {file_size};\n\n'
    
    # End namespace if specified
    if namespace:
        out += f'}} // namespace {namespace}\n\n'
    
    out += f'#endif // {header_guard}\n'
    
    return out


def write_header_file(header_content, varname, output_dir='./'):
    """ Write header content to file """
    if not os.path.exists(output_dir):
        os.makedirs(output_dir, exist_ok=True)
    
    output_filename = f'{varname}_embed.h'
    output_path = os.path.join(output_dir, output_filename)
    
    with open(output_path, 'w', encoding='utf-8') as f:
        f.write(header_content)
    
    return output_path


def main():
    """ Main func """
    parser = argparse.ArgumentParser(
        description='Convert binary file to C++ header file',
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog='''Examples:
  %(prog)s file.bin
  %(prog)s file.bin -v resource
  %(prog)s file.bin -v resource --linesize 80 --indent 4 --namespace resources
  %(prog)s file.bin -o ./headers/ -v mydata
  %(prog)s file.bin -o /tmp/generated/ --namespace embedded_files'''
    )
    
    parser.add_argument(
        'filename', help='filename to convert to C++ header')
    
    parser.add_argument(
        '-o', '--output-dir',
        help='output directory for generated header file',
        default='./')
    parser.add_argument(
        '-v', '--varname',
        help='base variable name (will have _data and _size suffixes added)',
        default='data')
    parser.add_argument(
        '-l', '--linesize',
        help='line length (default: 80, minimum: 40)',
        default=80, type=int)
    parser.add_argument(
        '-i', '--indent',
        help='indent size in spaces (default: 4)',
        default=4, type=int)
    parser.add_argument(
        '-n', '--namespace',
        help='C++ namespace to wrap the array',
        default=None)
    parser.add_argument(
        '-s', '--stdout',
        help='also print the header to stdout',
        action='store_true')
    
    args = parser.parse_args()
    
    # Generate the header
    header_content = bin2header(
        args.filename, 
        args.varname, 
        args.linesize, 
        args.indent,
        namespace=args.namespace
    )
    
    if header_content:
        # Write to file
        output_file = write_header_file(header_content, args.varname, args.output_dir)
        print(f'Generated header file: {output_file}')
        print(f'  Array variable name: {args.varname}_data')
        print(f'  Size variable name:  {args.varname}_size')
        
        if args.namespace:
            print(f'  Namespace:           {args.namespace}')
        
        if args.stdout:
            print('\n' + '-' * 60)
            print(header_content)
    else:
        print("Failed to generate header file.")


if __name__ == '__main__':
    main()